#!/tools/apps/ruby/bin/ruby.2.1.5 -w
#
# Ruby Vmgr (Vmanager) library
#
# Reads a .vsif file and creates a reduced sanity .vsif file.
# See USAGE.
# ---
# Author: Thorsten Dworzak <thorsten.dworzak@verilab.com>
# ---
#
require 'getoptlong'
require 'find'
require_relative '../lib/vmgr/collaterals.rb'
require_relative '../lib/vmgr/container.rb'
require_relative '../lib/vmgr/testcontainer.rb'
require_relative '../lib/vmgr/groupcontainer.rb'
require_relative '../lib/vmgr/sessioncontainer.rb'
require_relative '../lib/vmgr/session.rb'

#
# Globals
#

$USAGE="Usage:
#{$0} [<options>] <vsif-file>

This script reads a .vsif file and creates a reduced sanity .vsif file with all tests
running once with seed 1 (default). Tests with count 0 will be omitted.
The script will detect the attributes 'sanity_seed' and 'sanity_count' in the test container
that can be used to override the default seed+count values.

<options>:
--help, -h:
   print usage
--out, -o:
   name of output file (extension .vsif not required)

Example:
> #{$0} main.vsif -o sanity

"

#
# Module definition
#
module Vmgr

    ME = File.basename(__FILE__, ".rb")

    # Entry function to populate a new sanity session and override the old session container
    def Vmgr.make_sanity()
      # create new session container that will be populated from the parsed session container
      if nil != @session.session_container then
        sanity = SessionContainer.new(@session.session_container.name + "_sanity", "Sanity regression; automatically generated by script #{ME} from #{@vsif_file}", :vsif)
        Vmgr.make_sanity_core(@session.session_container, sanity)

        # overwrite old session container
        @session.session_container = sanity
        return true
      else
        STDERR.puts "#{ME} [WARNING]: nothing to be done"
        return false
      end
    end

    # Recursive function to populate to_container from from_container
    def Vmgr.make_sanity_core(from_container, to_container)
      from_container.hattribs.each {|key, value|
          case key
          when "sanity_count", "sanity_seed"    # do not show in output .vsif
            next
          when "groups"
            value.each { |it|
                new_group = GroupContainer.new(it.name)
                Vmgr.make_sanity_core(it, new_group)
                to_container.add_group(new_group) if new_group.has_attribute("tests") and !new_group.tests.empty?
            }
          when "tests"
            value.each { |it|
                new_test = TestContainer.new(it.name)
                Vmgr.make_sanity_core(it, new_test)

                begin
                  # override 'count' attribute
                  count = 1
                  if it.has_attribute("sanity_count") then
                    count = Integer(it.sanity_count.strip || ''); # avoid throwing TypeEerror for nil
                    new_test.add_attribute("count", count)
                  else
                    count = Integer(it.count.strip || '') if it.has_attribute("count")
                    new_test.delete_attribute("count")
                  end
                  if count == 0 then
                    puts "#{ME} [INFO]: skipping test #{it.name} with count 0"
                    next
                  end
                rescue ArgumentError
                  STDERR.puts "#{ME} [ERROR]: could not convert value to integer; in context = #{new_test.ctype} #{new_test.name}"
                  exit 1
                end

                # override 'seed' attribute
                if it.has_attribute("sanity_seed") then
                  new_test.add_attribute("seed", it.sanity_seed)
                else
                  new_test.delete_attribute("seed")
                end
                to_container.add_test(new_test)
            }
          else
            # replace count+seed from session + group containers
            skip = false
            if from_container.ctype != :test and ["count", "seed"].include?(key) then
                skip = true
            end
            # add default count to group
            if from_container.ctype == :group then
                to_container.add_attribute("count", "1")
            end
            # add default seed to group
            if from_container.ctype == :group then
                to_container.add_attribute("seed", "1")
            end

            to_container.add_attribute(key, value) if !skip
          end
      }
    end

    #
    # Main part of module
    # ---
    # Parse options
    @vsif_file = ""
    @vsif_dir = "."
    @vsif_out = "sanity.vsif"
    opts = GetoptLong.new( [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
                        [ '--out' , '-o', GetoptLong::OPTIONAL_ARGUMENT]
                        )
    opts.each { | opt, arg |
      case opt
      when '--help'
          puts $USAGE
          exit 0
      when '--out'
          @vsif_out = File.dirname(arg) + "/" + File.basename(arg, ".vsif") + ".vsif"
      end
    }

    if ARGV.size != 1 then
      STDERR.puts "#{ME} [ERROR]: must supply one vsif file as input"
      STDERR.puts $USAGE
      exit 1
    else
      @vsif_dir = File.dirname(ARGV[0])
      @vsif_file = File.basename(ARGV[0], ".vsif") + ".vsif"
    end

    save_dir = Dir.getwd()
    Dir.chdir(@vsif_dir)

    # Read .vsif and create new .vsif
    @session = Session.new("");
    if @session.read_vsif(@vsif_file) then
      if Vmgr.make_sanity() then
        @session.write_vsif(@vsif_out);
      end
    end

    Dir.chdir(save_dir)
end
